<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Padel Leaderboard</title>
  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --line:rgba(255,255,255,.12);
      --text:#e9ecff; --muted:rgba(233,236,255,.72);
      --accent: rgba(159,176,255,.22);
      --accent2: rgba(62,243,178,.18);
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background: radial-gradient(1200px 800px at 15% 0%, #1a2a6c 0%, #0b1020 55%);
      color:var(--text);
    }
    .wrap{max-width:1100px; margin:28px auto; padding:0 16px}
    .card{
      background: rgba(18,26,51,.86);
      border:1px solid var(--line);
      border-radius:18px;
      padding:14px;
      box-shadow: 0 12px 35px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
    }
    h1{margin:0; font-size:22px; letter-spacing:.3px}
    .sub{margin-top:6px; color:var(--muted); font-size:13px}
    .muted{color:var(--muted); font-size:12px}
    .toolbar{
      display:flex; gap:10px; flex-wrap:wrap;
      justify-content:space-between; align-items:center;
    }
    .right{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    input,select,button{
      padding:10px 12px; border-radius:12px;
      border:1px solid var(--line);
      background: rgba(11,16,32,.65);
      color: var(--text);
      outline:none;
    }
    input::placeholder{color:rgba(233,236,255,.45)}
    button{cursor:pointer}
    button:hover{background: rgba(159,176,255,.14)}
    .pill{
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--line);
      background: rgba(11,16,32,.55);
      font-size:12px; color:var(--muted);
    }

    /* Tabs */
    .tabs{
      display:flex; gap:8px; flex-wrap:wrap;
      margin-top: 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      padding-bottom: 10px;
    }
    .tabBtn{
      padding:10px 12px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(11,16,32,.55);
      font-size: 13px;
    }
    .tabBtn.active{
      background: rgba(159,176,255,.22);
      border-color: rgba(159,176,255,.45);
    }
    .tabPanel{ display:none; margin-top: 12px; }
    .tabPanel.active{ display:block; }

    /* Podium */
    .podium{
      display:grid; gap:10px;
      grid-template-columns: repeat(3, 1fr);
      margin-top:12px;
    }
    @media (max-width: 760px){
      .podium{grid-template-columns:1fr}
    }
    .podiumCard{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background: rgba(11,16,32,.55);
      transform: translateY(10px) scale(.98);
      opacity: 0;
      animation: podiumIn 650ms cubic-bezier(.2,.9,.2,1) forwards;
      will-change: transform, opacity;
    }
    .podiumCard:hover{
      transform: translateY(-2px) scale(1.01);
      transition: transform 180ms ease;
    }
    .podiumTitle{font-size:20px}
    .podiumMeta{margin-top:6px; color:var(--muted); font-size:12px; line-height:1.35}
    .podiumGlow{ position: relative; overflow: hidden; }
    .podiumGlow:before{
      content:"";
      position:absolute; inset:-40%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.18), transparent 55%);
      transform: rotate(12deg);
      opacity:.55;
      pointer-events:none;
    }
    @keyframes podiumIn{
      0%   { opacity:0; transform: translateY(14px) scale(.97); filter: blur(1px); }
      60%  { opacity:1; transform: translateY(0px)  scale(1.01); filter: blur(0px); }
      100% { opacity:1; transform: translateY(0px)  scale(1); }
    }

    /* Table wrapper: mobile spacing + right padding */
    .tableWrap{
      margin-top:12px;
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 10px;
    }
    table{
      width:100%;
      border-collapse:collapse;
      overflow:hidden;
      border-radius:14px;
      min-width: 760px;
    }
    th,td{
      padding:10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      text-align:left;
      white-space: nowrap;
    }
    th{font-size:12px; color:rgba(233,236,255,.75)}
    tbody tr:hover{background: rgba(159,176,255,.06)}
    .num{text-align:right; font-variant-numeric: tabular-nums}
    table th:last-child, table td:last-child{ padding-right: 18px; }

    /* Trend layout */
    .grid2{
      display:grid; gap: 12px;
      grid-template-columns: 1fr 1fr;
      margin-top: 12px;
    }
    @media (max-width: 860px){
      .grid2{ grid-template-columns: 1fr; }
    }
    .miniCard{
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background: rgba(11,16,32,.55);
    }
    .miniTitle{ font-size: 13px; color: rgba(233,236,255,.82); }
    .bigNum{ font-size: 26px; margin-top: 6px; font-weight: 700; letter-spacing:.2px; }
    canvas{
      width:100%;
      height: 240px;
      background: rgba(11,16,32,.40);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      display:block;
    }

    /* Mobile polish */
    @media (max-width: 480px){
      .wrap{padding:0 12px}
      .card{padding:12px}
      input,select{width: 100%;}
      .right{width:100%;}
    }
  
    /* =========================
       BROADCAST HIGHLIGHTS
       ========================= */
    .highlightGrid{
      display:grid;
      gap:12px;
      grid-template-columns: repeat(4, 1fr);
      margin-top: 12px;
    }
    @media (max-width: 980px){
      .highlightGrid{ grid-template-columns: repeat(2, 1fr); }
    }
    @media (max-width: 520px){
      .highlightGrid{ grid-template-columns: 1fr; }
    }
    .hiCard{
      position:relative;
      overflow:hidden;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background:
        radial-gradient(800px 240px at 15% 0%, rgba(159,176,255,.25), transparent 60%),
        radial-gradient(600px 240px at 85% 30%, rgba(62,243,178,.18), transparent 62%),
        linear-gradient(180deg, rgba(11,16,32,.72), rgba(11,16,32,.40));
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
      padding:14px 14px 12px;
    }
    .hiCard::before{
      content:"";
      position:absolute; inset:-40%;
      background: radial-gradient(circle at 20% 20%, rgba(255,255,255,.16), transparent 55%);
      transform: rotate(12deg);
      opacity:.55;
      pointer-events:none;
    }
    .hiTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .hiIcon{
      width:46px; height:46px;
      display:grid; place-items:center;
      border-radius:14px;
      background: rgba(159,176,255,.15);
      border: 1px solid rgba(159,176,255,.25);
      font-size:22px;
      flex:0 0 auto;
    }
    .hiLabel{
      font-size:12px;
      color: rgba(233,236,255,.72);
      letter-spacing:.2px;
    }
    .hiValue{
      margin-top:8px;
      font-size:26px;
      font-weight:800;
      letter-spacing:.2px;
      line-height:1.05;
    }
    .hiSub{
      margin-top:6px;
      font-size:12px;
      color: rgba(233,236,255,.60);
    }

    /* Cinematic canvas base */
    canvas{
      background:
        radial-gradient(900px 280px at 10% 0%, rgba(159,176,255,.10), transparent 60%),
        radial-gradient(700px 240px at 85% 40%, rgba(62,243,178,.08), transparent 60%),
        rgba(11,16,32,.40);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
    }

  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="toolbar">
        <div>
          <h1>Padel Leaderboard</h1>
          <div class="sub">Landing + Trends (Match Day & Individual). Auto refresh tiap 60 detik.</div>
        </div>

        <div class="right">
          <span class="pill">Last update: <b id="lastUpdate">-</b></span>
        </div>
      </div>

      <!-- Tabs -->
      <div class="tabs">
        <button class="tabBtn active" data-tab="tab1">Tab 1 ‚Äî Leaderboard</button>
        <button class="tabBtn" data-tab="tab2">Tab 2 ‚Äî Trend Match Day</button>
        <button class="tabBtn" data-tab="tab3">Tab 3 ‚Äî Trend Individual</button>
      </div>

      <!-- TAB 1: Leaderboard -->
      <section id="tab1" class="tabPanel active">
        <div class="toolbar" style="margin-top: 6px;">
          <div class="right" style="width:100%; justify-content:flex-end;">
            <input id="search" placeholder="Search nama..." />
            <select id="sortBy" title="Sort">
              <option value="points_desc">Points (tinggi ‚Üí rendah)</option>
              <option value="win_desc">Win (tinggi ‚Üí rendah)</option>
              <option value="winrate_desc">Winrate (tinggi ‚Üí rendah)</option>
              <option value="played_desc">Played (tinggi ‚Üí rendah)</option>
              <option value="name_asc">Name (A ‚Üí Z)</option>
            </select>
            <span class="pill">Total pemain: <b id="count">0</b></span>
          </div>
        </div>

        <div id="podium" class="podium"></div>

        <div class="tableWrap">
          <table>
            <thead>
              <tr>
                <th style="width:52px">#</th>
                <th>Name</th>
                <th class="num">Played</th>
                <th class="num">Win</th>
                <th class="num">Lose</th>
                <th class="num">Points</th>
                <th class="num">Winrate</th>
              </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>

        <div class="muted" style="margin-top:10px">
          Tab 2 & 3 butuh data ‚ÄúMatches‚Äù (per match day). Kalau belum ada, tinggal publish sheet Matches jadi  & tempel URL-nya di code.
        </div>
      </section>

      <!-- TAB 2: Trend Match Day -->
      <section id="tab2" class="tabPanel">
        <div class="toolbar" style="margin-top: 6px;">
          <div class="right" style="width:100%; justify-content:flex-end;">
            <select id="trendMonth" title="Month">
              <option value="all">All months</option>
              <option value="1">January</option><option value="2">February</option><option value="3">March</option>
              <option value="4">April</option><option value="5">May</option><option value="6">June</option>
              <option value="7">July</option><option value="8">August</option><option value="9">September</option>
              <option value="10">October</option><option value="11">November</option><option value="12">December</option>
            </select>
            <select id="trendRange">
              <option value="30">Last 30 days</option>
              <option value="60">Last 60 days</option>
              <option value="365">Last 365 days</option>
              <option value="all">All</option>
            </select>
            <span class="pill">Match days: <b id="mdCount">0</b></span>
          </div>
        </div>
        
          <div class="grid2">
  <div class="miniCard">
    <div class="miniTitle">Total Matches (range)</div>
    <div class="bigNum" id="totalMatchesRange">-</div>
    <div class="muted">Jumlah total played (akumulasi Win+Lose/Played) pada range.</div>
  </div>

  <div class="miniCard">
    <div class="miniTitle">Total Points (range)</div>
    <div class="bigNum" id="totalPointsRange">-</div>
    <div class="muted">Akumulasi points dari semua sesi di range.</div>
  </div>

  <div class="miniCard">
    <div class="miniTitle">Overall Winrate (range)</div>
    <div class="bigNum" id="overallWinrateRange">-</div>
    <div class="muted">Total win / (total win + total lose).</div>
  </div>

  <div class="miniCard">
    <div class="miniTitle">Winrate Streak ‚â• <span id="streakThresholdLabel">60</span>%</div>
    <div class="bigNum" id="winrateStreak">-</div>
    <div class="muted">Match day berturut-turut (dalam range) dengan winrate ‚â• threshold.</div>
  </div>
</div>

        <div class="highlightGrid">
          <div class="hiCard">
            <div class="hiTop">
              <div>
                <div class="hiLabel">Longest Winrate Streak (by day)</div>
                <div class="hiValue" id="hiLongestStreak">-</div>
                <div class="hiSub">Winrate day-streak ‚â• <span id="streakThresholdLabel2">60</span>%</div>
              </div>
              <div class="hiIcon">üî•</div>
            </div>
          </div>

          <div class="hiCard">
            <div class="hiTop">
              <div>
                <div class="hiLabel">Most Improved</div>
                <div class="hiValue" id="hiMostImproved">-</div>
                <div class="hiSub">Œî points vs periode sebelumnya (range sama)</div>
              </div>
              <div class="hiIcon">üìà</div>
            </div>
          </div>

          <div class="hiCard">
            <div class="hiTop">
              <div>
                <div class="hiLabel">Most Active</div>
                <div class="hiValue" id="hiMostActive">-</div>
                <div class="hiSub">Total played tertinggi (range)</div>
              </div>
              <div class="hiIcon">üèÜ</div>
            </div>
          </div>

          <div class="hiCard">
            <div class="hiTop">
              <div>
                <div class="hiLabel">Best Match Day</div>
                <div class="hiValue" id="hiBestDay">-</div>
                <div class="hiSub">Tanggal dengan points tertinggi (range)</div>
              </div>
              <div class="hiIcon">‚≠ê</div>
            </div>
          </div>
        </div>

      <div class="grid2">
  <div>
    <div class="muted" style="margin:6px 2px;">Total Points per Match Day</div>
    <canvas id="chartPointsDay" width="900" height="260"></canvas>
  </div>
  <div>
    <div class="muted" style="margin:6px 2px;">Cumulative Points (Growth)</div>
    <canvas id="chartPointsCum" width="900" height="260"></canvas>
  </div>
</div>

<div class="grid2">
  <div>
    <div class="muted" style="margin:6px 2px;">Total Matches per Match Day</div>
    <canvas id="chartMatchesDay" width="900" height="260"></canvas>
  </div>
  <div>
    <div class="muted" style="margin:6px 2px;">Club Winrate Trend per Match Day</div>
    <canvas id="chartWinrateDay" width="900" height="260"></canvas>
  </div>
</div>

        <div class="muted" style="margin-top:10px" id="matchesHint"></div>
      </section>

      <!-- TAB 3: Trend Individual -->
      <section id="tab3" class="tabPanel">
        <div class="toolbar" style="margin-top: 6px;">
          <div class="right" style="width:100%; justify-content:flex-end;">
            <select id="playerSelect"></select>
            <select id="playerMonth" title="Month">
              <option value="all">All months</option>
              <option value="1">January</option><option value="2">February</option><option value="3">March</option>
              <option value="4">April</option><option value="5">May</option><option value="6">June</option>
              <option value="7">July</option><option value="8">August</option><option value="9">September</option>
              <option value="10">October</option><option value="11">November</option><option value="12">December</option>
            </select>
            <select id="playerRange">
              <option value="30">Last 30 days</option>
              <option value="60">Last 60 days</option>
              <option value="365">Last 365 days</option>
              <option value="all">All</option>
            </select>
          </div>
        </div>

        <div class="grid2">
          <div class="miniCard">
            <div class="miniTitle">Player Matches (range)</div>
            <div class="bigNum" id="pMatches">-</div>
            <div class="muted">Jumlah match player di range.</div>
          </div>
          <div class="miniCard">
            <div class="miniTitle">Player Winrate (range)</div>
            <div class="bigNum" id="pWinrate">-</div>
            <div class="muted">Win / Played pada range.</div>
          </div>
        </div>

        <div class="highlightGrid">
          <div class="hiCard">
            <div class="hiTop">
              <div>
                <div class="hiLabel">Player Best Day</div>
                <div class="hiValue" id="pHiBestDay">-</div>
                <div class="hiSub">Best points day untuk player ini</div>
              </div>
              <div class="hiIcon">‚≠ê</div>
            </div>
          </div>

          <div class="hiCard">
            <div class="hiTop">
              <div>
                <div class="hiLabel">Player Longest Streak</div>
                <div class="hiValue" id="pHiStreak">-</div>
                <div class="hiSub">Winrate day-streak ‚â• 60%</div>
              </div>
              <div class="hiIcon">üî•</div>
            </div>
          </div>

          <div class="hiCard">
            <div class="hiTop">
              <div>
                <div class="hiLabel">Avg Points / Day</div>
                <div class="hiValue" id="pHiAvgPts">-</div>
                <div class="hiSub">Rata-rata points per match day</div>
              </div>
              <div class="hiIcon">üéØ</div>
            </div>
          </div>

          <div class="hiCard">
            <div class="hiTop">
              <div>
                <div class="hiLabel">Total Played</div>
                <div class="hiValue" id="pHiPlayed">-</div>
                <div class="hiSub">Total played pada filter aktif</div>
              </div>
              <div class="hiIcon">üß±</div>
            </div>
          </div>
        </div>


        <div class="grid2">
          <div>
            <div class="muted" style="margin:6px 2px;">Player Points per Match Day</div>
            <canvas id="chartPlayerPts" width="900" height="260"></canvas>
          </div>
          <div>
            <div class="muted" style="margin:6px 2px;">Player Cumulative Points</div>
            <canvas id="chartPlayerCum" width="900" height="260"></canvas>
          </div>
        </div>

        <div class="muted" style="margin-top:10px" id="playerHint"></div>
      </section>

    </div>
  </div>

<script>
  /* =========================
  NOTES (PLEASE READ):
  1) Semua ID yang dipakai JS harus exist di HTML. Gunakan safeSet agar tidak crash.
  2) Highlights & charts mengikuti filter yang dipilih:
     - trendRange: Last 30/60/365/All
     - trendMonth/playerMonth: January‚ÄìDecember atau All months
  3) Tab 1 tetap render walau Matches gagal load ‚Üí loadAll() dipisah try/catch.
  ========================= */

// =========================
  // 1) LEADERBOARD CSV (kamu sudah punya)
  // =========================
  const LEADERBOARD_CSV_URL =
    "https://docs.google.com/spreadsheets/d/e/2PACX-1vQa_3k4XRT_CetrvxU0E2wlGlsis3bbt9mRFk85jfLb8w4FsGBxadPNPGQRdjkCU9_4Wywmu1wr2f9P/pub?gid=0&single=true&output=csv";

  // =========================
  // 2) MATCHES CSV (buat trend)
  // Isi jika kamu sudah publish sheet Matches ‚Üí output=csv
  // Contoh format kolom: Date, Player, Result(W/L), Points
  // =========================
  const MATCHES_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTvKFiHbg-Ax_1oxD1fm_FSPZLhk1KgYSF7ndVVccl3TTv-IH7y7vQFd6ezx0QqUJ9iAyFqyCkVPJAB/pub?gid=0&single=true&output=csv"; // <-- tempel di sini nanti

  let leaderboardRows = [];
  let matchesRows = []; // {date: 'YYYY-MM-DD', player:'', result:'W/L', points:number}

  // elements
  const elLastUpdate = document.getElementById("lastUpdate");

  // tab 1
  const elTbody = document.getElementById("tbody");
  const elSearch = document.getElementById("search");
  const elSortBy = document.getElementById("sortBy");
  const elCount  = document.getElementById("count");
  const elPodium = document.getElementById("podium");

  // tab 2
  const elTrendRange = document.getElementById("trendRange");
  const elTrendMonth = document.getElementById("trendMonth");
  const elMdCount = document.getElementById("mdCount");
  const elTotalMatchesRange = document.getElementById("totalMatchesRange");
  const elTotalPointsRange = document.getElementById("totalPointsRange");
  const elMatchesHint = document.getElementById("matchesHint");
  const cPointsDay = document.getElementById("chartPointsDay");
  const cPointsCum = document.getElementById("chartPointsCum");
  const elOverallWinrateRange = document.getElementById("overallWinrateRange");
const elWinrateStreak = document.getElementById("winrateStreak");
const elStreakThresholdLabel = document.getElementById("streakThresholdLabel");
  const elStreakThresholdLabel2 = document.getElementById("streakThresholdLabel2");
const cMatchesDay = document.getElementById("chartMatchesDay");
const cWinrateDay = document.getElementById("chartWinrateDay");

  const elHiLongestStreak = document.getElementById("hiLongestStreak");
  const elHiMostImproved = document.getElementById("hiMostImproved");
  const elHiMostActive = document.getElementById("hiMostActive");
  const elHiBestDay = document.getElementById("hiBestDay");



  // tab 3
  const elPlayerSelect = document.getElementById("playerSelect");
  const elPlayerRange = document.getElementById("playerRange");
  const elPlayerMonth = document.getElementById("playerMonth");
  const elPMatches = document.getElementById("pMatches");
  const elPWinrate = document.getElementById("pWinrate");
  const elPlayerHint = document.getElementById("playerHint");
  const cPlayerPts = document.getElementById("chartPlayerPts");
  const cPlayerCum = document.getElementById("chartPlayerCum");

  const elPHiBestDay = document.getElementById("pHiBestDay");
  const elPHiStreak = document.getElementById("pHiStreak");
  const elPHiAvgPts = document.getElementById("pHiAvgPts");
  const elPHiPlayed = document.getElementById("pHiPlayed");

  // =========================
  // Utilities
  // =========================
  function safeSet(el, val){
    if (el) el.textContent = val;
  }

  function applyMonthFilter(records, monthValue){
    if (!monthValue || monthValue === "all") return records;
    const m = Number(monthValue);
    return records.filter(r => Number(String(r.date).slice(5,7)) === m);
  }

  
function longestWinrateStreak(days, thresholdPct){
  // days = array hasil groupByDate: [{date, wins, losses, ...}]
  let best = 0, cur = 0;

  for (const d of days){
    const played = (d.wins || 0) + (d.losses || 0);
    const wr = played ? (d.wins / played) * 100 : 0;

    if (wr >= thresholdPct){
      cur += 1;
      if (cur > best) best = cur;
    } else {
      cur = 0;
    }
  }
  return best;
}

  
  function toNum(v){
    const n = Number(String(v ?? "").trim());
    return Number.isFinite(n) ? n : 0;
  }
  function escapeHtml(str){
    return String(str ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function normalizeHeaders(h){
    return String(h || "").trim().toLowerCase();
  }
  function winrate(p){
    if (!p.played) return 0;
    return (p.win / p.played) * 100;
  }

  // CSV parser (supports quoted values)
  function parseCSV(text){
    const out = [];
    let row = [];
    let cur = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++){
      const ch = text[i];
      const next = text[i+1];

      if (ch === '"' && inQuotes && next === '"') { cur += '"'; i++; continue; }
      if (ch === '"') { inQuotes = !inQuotes; continue; }

      if (!inQuotes && ch === ","){ row.push(cur); cur = ""; continue; }

      if (!inQuotes && (ch === "\n" || ch === "\r")){
        if (ch === "\r" && next === "\n") i++;
        row.push(cur);
        if (row.some(cell => String(cell).trim() !== "")) out.push(row);
        row = []; cur = "";
        continue;
      }
      cur += ch;
    }
    row.push(cur);
    if (row.some(cell => String(cell).trim() !== "")) out.push(row);
    return out;
  }

  // =========================
  // Leaderboard mapping (robust)
  // =========================
  function toLeaderboardPlayers(parsed){
    const header = (parsed[0] || []).map(h => normalizeHeaders(h));

    function findIdx(candidates){
      for (const c of candidates){
        const i = header.indexOf(c);
        if (i !== -1) return i;
      }
      return -1;
    }

    const iName   = findIdx(["name","nama","player","pemain"]);
    const iPlayed = findIdx(["played","main","games","match"]);
    const iWin    = findIdx(["win","menang","w"]);
    const iLose   = findIdx(["lose","loss","kalah","l"]);
    const iPoints = findIdx(["points","poin","point","skor","score"]);

    const fallback = { iName:0, iPlayed:1, iWin:2, iLose:3, iPoints:4 };

    const idx = {
      name:   iName   !== -1 ? iName   : fallback.iName,
      played: iPlayed !== -1 ? iPlayed : fallback.iPlayed,
      win:    iWin    !== -1 ? iWin    : fallback.iWin,
      lose:   iLose   !== -1 ? iLose   : fallback.iLose,
      points: iPoints !== -1 ? iPoints : fallback.iPoints,
    };

    return parsed.slice(1).map(cols => ({
      name: (cols[idx.name] || "").trim(),
      played: toNum(cols[idx.played]),
      win: toNum(cols[idx.win]),
      lose: toNum(cols[idx.lose]),
      points: toNum(cols[idx.points]),
    })).filter(p => p.name);
  }

  // =========================
  // Matches mapping (Date/Player/Result/Points)
  // =========================
  function toMatches(parsed){
  const header = (parsed[0] || []).map(h => normalizeHeaders(h));

  function findIdx(candidates){
    for (const c of candidates){
      const i = header.indexOf(c);
      if (i !== -1) return i;
    }
    return -1;
  }

  const iDate   = findIdx(["date","tanggal"]);
  const iSess   = findIdx(["session/court","session","court","venue","lapangan"]);
  const iPlayer = findIdx(["player","name","nama","pemain"]);
  const iWin    = findIdx(["win","menang","w"]);
  const iLose   = findIdx(["lose","loss","kalah","l"]);
  const iPoints = findIdx(["points","poin","point","skor","score"]);
  const iPlayed = findIdx(["played","main","games","match"]);

  if (iDate === -1 || iPlayer === -1) return [];

  return parsed.slice(1).map(cols => {
    const rawDate = (cols[iDate] || "").trim();
    const date = normalizeDate(rawDate);

    const player = (cols[iPlayer] || "").trim();
    const session = iSess !== -1 ? (cols[iSess] || "").trim() : "";

    const wins = iWin !== -1 ? toNum(cols[iWin]) : 0;
    const losses = iLose !== -1 ? toNum(cols[iLose]) : 0;

    // played kadang ada di CSV, tapi kalau nggak ada / kosong, kita hitung dari win+lose
    const playedFromCol = iPlayed !== -1 ? toNum(cols[iPlayed]) : 0;
    const played = playedFromCol || (wins + losses);

    const points = iPoints !== -1 ? toNum(cols[iPoints]) : 0;

    return { date, session, player, wins, losses, played, points };
  }).filter(r => r.date && r.player);
}


  function normalizeDate(s){
    // supports: YYYY-MM-DD, YYYY/MM/DD, DD/MM/YYYY, etc. Best effort.
    const t = String(s || "").trim();
    if (!t) return "";

    // already ISO-like
    const iso = t.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
    if (iso){
      const y = iso[1];
      const m = String(iso[2]).padStart(2,"0");
      const d = String(iso[3]).padStart(2,"0");
      return `${y}-${m}-${d}`;
    }

    // DD/MM/YYYY
    const dmy = t.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/);
    if (dmy){
      const d = String(dmy[1]).padStart(2,"0");
      const m = String(dmy[2]).padStart(2,"0");
      const y = dmy[3];
      return `${y}-${m}-${d}`;
    }

    // fallback: try Date parse
    const dt = new Date(t);
    if (!isNaN(dt.getTime())){
      const y = dt.getFullYear();
      const m = String(dt.getMonth()+1).padStart(2,"0");
      const d = String(dt.getDate()).padStart(2,"0");
      return `${y}-${m}-${d}`;
    }

    return "";
  }

  function nowHHMM(){
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }

  // =========================
  // Tabs
  // =========================
  document.querySelectorAll(".tabBtn").forEach(btn => {
    btn.addEventListener("click", () => {
      document.querySelectorAll(".tabBtn").forEach(b => b.classList.remove("active"));
      document.querySelectorAll(".tabPanel").forEach(p => p.classList.remove("active"));
      btn.classList.add("active");
      document.getElementById(btn.dataset.tab).classList.add("active");

      // refresh charts when user opens tab
      if (btn.dataset.tab === "tab2") renderMatchDayTrends();
      if (btn.dataset.tab === "tab3") renderPlayerTrends();
    });
  });

  // =========================
  // Tab 1: Sorting + rendering
  // =========================
  function applyFilterSort(list){
    const q = elSearch.value.trim().toLowerCase();
    let out = q ? list.filter(p => p.name.toLowerCase().includes(q)) : [...list];

    const mode = elSortBy.value;
    out.sort((a,b)=>{
      if (mode === "points_desc") return (b.points-a.points) || (b.win-a.win) || a.name.localeCompare(b.name);
      if (mode === "win_desc") return (b.win-a.win) || (b.points-a.points) || a.name.localeCompare(b.name);
      if (mode === "winrate_desc") {
        const wa = a.played ? a.win / a.played : 0;
        const wb = b.played ? b.win / b.played : 0;
        return (wb - wa) || (b.points - a.points) || a.name.localeCompare(b.name);
      }
      if (mode === "played_desc") return (b.played-a.played) || (b.points-a.points) || a.name.localeCompare(b.name);
      if (mode === "name_asc") return a.name.localeCompare(b.name);
      return 0;
    });

    return out;
  }

  function renderPodium(allRows){
    const mode = elSortBy.value;

    const sorted = [...allRows].sort((a,b)=>{
      if (mode === "points_desc") return (b.points-a.points) || (b.win-a.win) || a.name.localeCompare(b.name);
      if (mode === "win_desc") return (b.win-a.win) || (b.points-a.points) || a.name.localeCompare(b.name);
      if (mode === "winrate_desc") {
        const wa = a.played ? a.win / a.played : 0;
        const wb = b.played ? b.win / b.played : 0;
        return (wb - wa) || (b.points - a.points) || a.name.localeCompare(b.name);
      }
      if (mode === "played_desc") return (b.played-a.played) || (b.points-a.points) || a.name.localeCompare(b.name);
      if (mode === "name_asc") return a.name.localeCompare(b.name);
      return 0;
    });

    const top = sorted.slice(0,3);
    const medals = ["ü•á","ü•à","ü•â"];
    elPodium.innerHTML = "";

    if (top.length === 0){
      elPodium.innerHTML = `<div class="muted">Belum ada data untuk podium.</div>`;
      return;
    }

    top.forEach((p, i)=>{
      const wr = winrate(p).toFixed(1) + "%";
      const div = document.createElement("div");
      div.className = "podiumCard podiumGlow";
      div.style.animationDelay = `${i * 120}ms`;
      div.innerHTML = `
        <div class="podiumTitle">${medals[i]} <b>${escapeHtml(p.name)}</b></div>
        <div class="podiumMeta">
          Played: <b>${p.played}</b> ‚Ä¢ W: <b>${p.win}</b> ‚Ä¢ L: <b>${p.lose}</b><br/>
          Points: <b>${p.points}</b> ‚Ä¢ Winrate: <b>${wr}</b>
        </div>
      `;
      elPodium.appendChild(div);
    });
  }

  function renderLeaderboard(){
    const list = applyFilterSort(leaderboardRows);
    elCount.textContent = String(leaderboardRows.length);
    elTbody.innerHTML = "";

    if (leaderboardRows.length === 0){
      elTbody.innerHTML = `<tr><td colspan="7" class="muted">Data kosong / belum kebaca dari CSV.</td></tr>`;
      return;
    }

    list.forEach((p, idx)=>{
      const wr = winrate(p).toFixed(1) + "%";
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="muted">${idx+1}</td>
        <td><b>${escapeHtml(p.name)}</b></td>
        <td class="num">${p.played}</td>
        <td class="num">${p.win}</td>
        <td class="num">${p.lose}</td>
        <td class="num"><b>${p.points}</b></td>
        <td class="num">${wr}</td>
      `;
      elTbody.appendChild(tr);
    });
  }

  elSearch.addEventListener("input", () => renderLeaderboard());
  elSortBy.addEventListener("change", () => {
    elPodium.innerHTML = "";
    renderPodium(leaderboardRows);
    renderLeaderboard();
  });

  // TAB 2 & TAB 3 listeners (keep UI reactive)
  if (elTrendRange) elTrendRange.addEventListener("change", renderMatchDayTrends);
  if (elTrendMonth) elTrendMonth.addEventListener("change", renderMatchDayTrends);

  if (elPlayerSelect) elPlayerSelect.addEventListener("change", renderPlayerTrends);
  if (elPlayerRange) elPlayerRange.addEventListener("change", renderPlayerTrends);
  if (elPlayerMonth) elPlayerMonth.addEventListener("change", renderPlayerTrends);

  // =========================
  // Trends helpers (Match Day aggregation)
  // =========================
  function filterByRange(records, daysOrAll){
    if (daysOrAll === "all") return [...records];
    const days = Number(daysOrAll);
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - days);

    return records.filter(r => {
      const d = new Date(r.date + "T00:00:00");
      return !isNaN(d.getTime()) && d >= cutoff;
    });
  }

  function groupByDate(records){
  const map = new Map();

  records.forEach(r => {
    if (!map.has(r.date)) map.set(r.date, {date:r.date, matches:0, points:0, wins:0, losses:0});
    const g = map.get(r.date);

    g.matches += (r.played || (r.wins||0) + (r.losses||0));
    g.points  += (r.points || 0);
    g.wins    += (r.wins || 0);
    g.losses  += (r.losses || 0);
  });

  return Array.from(map.values()).sort((a,b)=> a.date.localeCompare(b.date));
}

  // =========================
  // Tiny canvas chart (line)
  // =========================
  function drawLineChart(canvas, labels, values, title, suffix=""){
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const w = canvas.width;
    const h = canvas.height;

    // store data for hover tooltip
    canvas._chartData = { labels, values, suffix, title };

    // clear
    ctx.clearRect(0,0,w,h);

    // padding
    const padL = 56, padR = 18, padT = 18, padB = 34;
    const plotW = w - padL - padR;
    const plotH = h - padT - padB;

    // title
    ctx.fillStyle = "rgba(233,236,255,.85)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(title || "", padL, 14);

    if (!values || values.length === 0){
      ctx.fillStyle = "rgba(233,236,255,.6)";
      ctx.fillText("No data", padL, padT + 18);
      return;
    }

    const minV = Math.min(...values);
    const maxV = Math.max(...values);
    const span = (maxV - minV) || 1;

    // grid + y ticks (5 lines)
    ctx.strokeStyle = "rgba(255,255,255,.07)";
    ctx.lineWidth = 1;
    ctx.fillStyle = "rgba(233,236,255,.55)";
    ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";

    for (let i=0;i<=4;i++){
      const y = padT + (plotH * i/4);
      const val = maxV - (span * i/4);
      ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL+plotW, y); ctx.stroke();
      ctx.fillText(`${val.toFixed(1)}${suffix}`, 10, y+4);
    }

    // line
    ctx.strokeStyle = "rgba(159,176,255,.90)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    values.forEach((v, i)=>{
      const x = padL + (plotW * (values.length===1 ? 0 : i/(values.length-1)));
      const y = padT + plotH - ((v - minV)/span) * plotH;
      if (i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // points
    ctx.fillStyle = "rgba(62,243,178,.85)";
    values.forEach((v, i)=>{
      const x = padL + (plotW * (values.length===1 ? 0 : i/(values.length-1)));
      const y = padT + plotH - ((v - minV)/span) * plotH;
      ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
    });

    // x labels (first + last)
    const first = labels[0] || "";
    const last = labels[labels.length-1] || "";
    ctx.fillStyle = "rgba(233,236,255,.55)";
    ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(first, padL, h-12);
    const lastW = ctx.measureText(last).width;
    ctx.fillText(last, padL+plotW-lastW, h-12);

    // last value label
    const lastVal = values[values.length-1];
    ctx.fillStyle = "rgba(233,236,255,.85)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Last: ${lastVal.toFixed(1)}${suffix}`, padL+plotW-150, 14);

    // tooltip overlay if active
    if (canvas._hoverIndex != null){
      const i = canvas._hoverIndex;
      const v = values[i];
      const x = padL + (plotW * (values.length===1 ? 0 : i/(values.length-1)));
      const y = padT + plotH - ((v - minV)/span) * plotH;

      // crosshair
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT+plotH); ctx.stroke();

      // tooltip box
      const label = labels[i] || "";
      const msg = `${label} ‚Ä¢ ${v.toFixed(1)}${suffix}`;
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      const tw = ctx.measureText(msg).width;
      const bx = Math.min(padL+plotW- (tw+18), Math.max(padL, x - tw/2 - 9));
      const by = Math.max(padT+6, y - 34);

      ctx.fillStyle = "rgba(11,16,32,.78)";
      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.lineWidth = 1;
      roundRect(ctx, bx, by, tw+18, 26, 10, true, true);

      ctx.fillStyle = "rgba(233,236,255,.92)";
      ctx.fillText(msg, bx+9, by+17);
    }
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function enableChartHover(canvas){
    if (!canvas || canvas._hoverEnabled) return;
    canvas._hoverEnabled = true;
    canvas.addEventListener("mousemove", (e)=>{
      const data = canvas._chartData;
      if (!data || !data.values || data.values.length === 0) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;

      const padL = 56, padR = 18;
      const plotW = canvas.width - padL - padR;

      const n = data.values.length;
      const t = (x - padL) / plotW;
      const i = Math.max(0, Math.min(n-1, Math.round(t*(n-1))));
      canvas._hoverIndex = i;
      drawLineChart(canvas, data.labels, data.values, data.title, data.suffix);
    });
    canvas.addEventListener("mouseleave", ()=>{
      const data = canvas._chartData;
      canvas._hoverIndex = null;
      if (data) drawLineChart(canvas, data.labels, data.values, data.title, data.suffix);
    });
  }


function safeChart(canvas, labels, values, title, suffix=""){
  if (!canvas) return;
  drawLineChart(canvas, labels, values, title, suffix);
  enableChartHover(canvas);
}
  
 function bestMatchDay(byDay){
  if (!byDay.length) return "-";
  let best = byDay[0];
  for (const d of byDay){ if (d.points > best.points) best = d; }
  return `${best.date} (${best.points} pts)`;
}

function mostActivePlayer(records){
  const map = new Map();
  records.forEach(r=>{
    const played = r.played || ((r.wins||0)+(r.losses||0));
    map.set(r.player, (map.get(r.player)||0) + played);
  });
  let bestP="", bestV=-1;
  for (const [p,v] of map.entries()) if (v>bestV){ bestV=v; bestP=p; }
  return bestP ? `${bestP} (${bestV})` : "-";
}

function totalPointsByPlayer(records){
  const map = new Map();
  records.forEach(r=> map.set(r.player, (map.get(r.player)||0) + (r.points||0)));
  return map;
}

function mostImproved(current, previous){
  if (!previous.length) return "-";
  const cur = totalPointsByPlayer(current);
  const prev = totalPointsByPlayer(previous);
  const players = new Set([...cur.keys(), ...prev.keys()]);
  let bestP="", bestDelta=-Infinity;
  for (const p of players){
    const d = (cur.get(p)||0) - (prev.get(p)||0);
    if (d>bestDelta){ bestDelta=d; bestP=p; }
  }
  if (!bestP) return "-";
  const sign = bestDelta>=0 ? "+" : "";
  return `${bestP} (${sign}${bestDelta} pts)`;
}

function longestWinrateStreak(days, thresholdPct){
  let best=0, cur=0;
  for (const d of days){
    const played = (d.wins||0) + (d.losses||0);
    const wr = played ? (d.wins/played)*100 : 0;
    if (wr >= thresholdPct){ cur++; best = Math.max(best, cur); }
    else cur = 0;
  }
  return best;
}

function longestStreakByPlayer(records, threshold){
  const byPlayer = new Map();
  records.forEach(r=>{
    if (!byPlayer.has(r.player)) byPlayer.set(r.player, []);
    byPlayer.get(r.player).push(r);
  });
  let bestP="", bestS=0;
  for (const [p,recs] of byPlayer.entries()){
    const map = new Map();
    recs.forEach(rr=>{
      if (!map.has(rr.date)) map.set(rr.date, {wins:0,losses:0,points:0});
      const g = map.get(rr.date);
      g.wins += (rr.wins||0);
      g.losses += (rr.losses||0);
    });
    const days = Array.from(map.entries())
      .sort((a,b)=>a[0].localeCompare(b[0]))
      .map(([date,v])=>({date, wins:v.wins, losses:v.losses}));
    const s = longestWinrateStreak(days, threshold);
    if (s>bestS){ bestS=s; bestP=p; }
  }
  return bestP ? `${bestP} (${bestS} days)` : "-";
}

function renderMatchDayTrends(){
  const THRESHOLD = 60;
  safeSet(elStreakThresholdLabel, String(THRESHOLD));
  safeSet(elStreakThresholdLabel2, String(THRESHOLD));

  if (!MATCHES_CSV_URL){
    safeSet(elMatchesHint,
      "Tab trend butuh MATCHES_CSV_URL. Publish sheet Matches sebagai CSV (output=csv), lalu tempel URL-nya ke const MATCHES_CSV_URL."
    );
    safeSet(elMdCount, "0");
    safeSet(elTotalMatchesRange, "-");
    safeSet(elTotalPointsRange, "-");
    safeSet(elOverallWinrateRange, "-");
    safeSet(elWinrateStreak, "-");

    safeSet(elHiLongestStreak, "-");
    safeSet(elHiMostImproved, "-");
    safeSet(elHiMostActive, "-");
    safeSet(elHiBestDay, "-");

    safeChart(cPointsDay, [], [], "Total Points per Match Day");
    safeChart(cPointsCum, [], [], "Cumulative Points (Growth)");
    safeChart(cMatchesDay, [], [], "Total Matches per Match Day");
    safeChart(cWinrateDay, [], [], "Club Winrate Trend per Match Day", "%");
    return;
  }

  // Filter: range + month
  let ranged = filterByRange(matchesRows, elTrendRange.value);
  ranged = applyMonthFilter(ranged, elTrendMonth ? elTrendMonth.value : "all");

  const byDay = groupByDate(ranged);
  safeSet(elMdCount, String(byDay.length));
  safeSet(elMatchesHint, byDay.length ? "" : "Tidak ada data pada filter ini.");

  // KPI totals
  const totalMatches = ranged.reduce((s,r)=> s + (r.played || ((r.wins||0)+(r.losses||0))), 0);
  const totalPoints  = ranged.reduce((s,r)=> s + (r.points||0), 0);
  const totalWins    = ranged.reduce((s,r)=> s + (r.wins||0), 0);
  const totalLosses  = ranged.reduce((s,r)=> s + (r.losses||0), 0);
  const playedWL     = totalWins + totalLosses;
  const overallWR    = playedWL ? ((totalWins/playedWL)*100).toFixed(1) + "%" : "0.0%";

  safeSet(elTotalMatchesRange, String(totalMatches));
  safeSet(elTotalPointsRange, String(totalPoints));
  safeSet(elOverallWinrateRange, overallWR);

  // Streak: consecutive match days with winrate >= threshold
  const streak = longestWinrateStreak(byDay, THRESHOLD);
  safeSet(elWinrateStreak, String(streak) + " days");

  // Highlights (club-wide)
  safeSet(elHiBestDay, bestMatchDay(byDay));
  safeSet(elHiMostActive, mostActivePlayer(ranged));
  safeSet(elHiLongestStreak, longestStreakByPlayer(ranged, THRESHOLD));

  // Most improved = current period vs previous period (same range length)
  if (elTrendRange.value !== "all"){
    const days = Number(elTrendRange.value);
    const now = new Date();
    const start = new Date(); start.setDate(now.getDate() - days);
    const prevStart = new Date(); prevStart.setDate(now.getDate() - (2*days));

    let prev = matchesRows.filter(r=>{
      const d = new Date(r.date + "T00:00:00");
      return d >= prevStart && d < start;
    });
    prev = applyMonthFilter(prev, elTrendMonth ? elTrendMonth.value : "all");

    safeSet(elHiMostImproved, mostImproved(ranged, prev));
  } else {
    safeSet(elHiMostImproved, "-");
  }

  // Charts
  const labels = byDay.map(d => d.date);
  const ptsDay = byDay.map(d => d.points);
  const matchesDay = byDay.map(d => d.matches);
  const winrateDay = byDay.map(d => {
    const p = (d.wins||0) + (d.losses||0);
    return p ? (d.wins/p)*100 : 0;
  });

  // cumulative points
  let acc = 0;
  const ptsCum = ptsDay.map(v => (acc += v));

  safeChart(cPointsDay, labels, ptsDay, "Total Points per Match Day");
  safeChart(cPointsCum, labels, ptsCum, "Cumulative Points (Growth)");
  safeChart(cMatchesDay, labels, matchesDay, "Total Matches per Match Day");
  safeChart(cWinrateDay, labels, winrateDay, "Club Winrate Trend per Match Day", "%");
}


function renderPlayerSelect(){
    const players = uniquePlayersFromMatches();
    elPlayerSelect.innerHTML = "";
    if (!players.length){
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "No players";
      elPlayerSelect.appendChild(opt);
      return;
    }
    players.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      elPlayerSelect.appendChild(opt);
    });
  }

  function renderPlayerTrends(){
  if (!MATCHES_CSV_URL){
    safeSet(elPlayerHint,
      "Tab ini butuh MATCHES_CSV_URL (sheet Matches). Publish as CSV, lalu tempel URL-nya di code."
    );
    safeSet(elPMatches, "-");
    safeSet(elPWinrate, "-");
    safeSet(elPHiBestDay, "-");
    safeSet(elPHiStreak, "-");
    safeSet(elPHiAvgPts, "-");
    safeSet(elPHiPlayed, "-");
    safeChart(cPlayerPts, [], [], "Player Points per Match Day");
    safeChart(cPlayerCum, [], [], "Player Cumulative Points");
    return;
  }

  const player = (elPlayerSelect && elPlayerSelect.value) ? elPlayerSelect.value : "";
  if (!player){
    safeSet(elPlayerHint, "Pilih player dulu.");
    safeSet(elPMatches, "-");
    safeSet(elPWinrate, "-");
    return;
  }

  // Filter: range + month + player
  let ranged = filterByRange(matchesRows, elPlayerRange.value).filter(r => r.player === player);
  ranged = applyMonthFilter(ranged, elPlayerMonth ? elPlayerMonth.value : "all");

  safeSet(elPlayerHint, ranged.length ? "" : "Tidak ada data pada filter ini.");

  // totals
  const wins = ranged.reduce((s,r)=> s + (r.wins||0), 0);
  const losses = ranged.reduce((s,r)=> s + (r.losses||0), 0);
  const played = wins + losses;
  const wr = played ? ((wins/played)*100).toFixed(1) + "%" : "0.0%";

  safeSet(elPMatches, String(played));
  safeSet(elPWinrate, wr);

  // by day
  const byDay = groupByDate(ranged);
  const labels = byDay.map(d => d.date);
  const ptsDay = byDay.map(d => d.points);

  let acc = 0;
  const ptsCum = ptsDay.map(v => (acc += v));

  safeChart(cPlayerPts, labels, ptsDay, "Player Points per Match Day");
  safeChart(cPlayerCum, labels, ptsCum, "Player Cumulative Points");

  // Player highlights (same style as tab2)
  safeSet(elPHiPlayed, String(played));
  safeSet(elPHiBestDay, bestMatchDay(byDay));
  const streak = longestWinrateStreak(byDay, 60);
  safeSet(elPHiStreak, String(streak) + " days");
  const avgPts = byDay.length ? (byDay.reduce((s,d)=>s + d.points, 0) / byDay.length) : 0;
  safeSet(elPHiAvgPts, avgPts.toFixed(1));
}


async function loadLeaderboard(){
    const res = await fetch(LEADERBOARD_CSV_URL, { cache: "no-store" });
    const text = await res.text();
    const parsed = parseCSV(text);
    leaderboardRows = parsed.length ? toLeaderboardPlayers(parsed) : [];
  }

  async function loadMatches(){
    if (!MATCHES_CSV_URL) { matchesRows = []; return; }
    const res = await fetch(MATCHES_CSV_URL, { cache: "no-store" });
    const text = await res.text();
    const parsed = parseCSV(text);
    matchesRows = parsed.length ? toMatches(parsed) : [];
  }

async function loadAll(){
  // Leaderboard should render even if Matches fails
  try{
    await loadLeaderboard();
    safeSet(elLastUpdate, nowHHMM());
    elPodium.innerHTML = "";
    renderPodium(leaderboardRows);
    renderLeaderboard();
  } catch (e){
    console.error("Leaderboard load failed:", e);
  }

  // Matches (tabs 2 & 3) should not break tab1
  try{
    await loadMatches();
    if (MATCHES_CSV_URL){
      renderMatchDayTrends();
      renderPlayerSelect();
      renderPlayerTrends();
    } else {
      renderMatchDayTrends();
      renderPlayerTrends();
    }
  } catch (e){
    console.error("Matches load failed:", e);
    // still try to render empty states
    renderMatchDayTrends();
    renderPlayerTrends();
  }
}

  loadAll();
  setInterval(loadAll, 60000);
</script>
</body>
</html>



